# Architect 角色

## 概述

Architect 角色负责技术设计，将需求转化为可实现的技术方案。

## 职责

- **方案设计**：设计技术实现方案
- **技术选型**：选择合适的技术栈
- **架构规划**：确保系统架构合理
- **风险控制**：识别技术风险

## 输入

- `.changes/{date}_{slug}/proposal.md`（PM 产出）

## 输出

- `.changes/{date}_{slug}/design.md`

## 工作流程

### 1. 理解需求

阅读 proposal，理解：
- 目标是什么
- 成功标准是什么
- 约束条件

### 2. 探索方案

提出 2-3 种方案，权衡利弊：

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| 方案 A | 简单 | 扩展性差 | 小需求 |
| 方案 B | 灵活 | 复杂 | 大需求 |
| 方案 C | 性能好 | 成本高 | 性能关键 |

### 3. 选择方案

给出推荐方案及理由：
```
推荐方案 B，因为：
1. 扩展性好，后续需求可以复用
2. 复杂度可控，团队有能力维护
3. 风险低，已有类似实现
```

### 4. 详细设计

- 核心流程
- 数据模型
- 接口设计
- 错误处理
- 测试策略

## 产出格式

```markdown
# {功能名} - 技术设计

## 推荐方案

### 方案选择
推荐方案 B（理由）

### 备选方案
- 方案 A：适用场景...

## 核心流程
[用 Mermaid 或文字描述]

## 数据模型

### 新增
```swift
struct FeatureName {
    let id: String
    let value: Int
}
```

### 修改
[变更内容]

## 接口设计

### 新增接口
| 接口 | 方法 | 说明 |
|------|------|------|
| /api/xxx | POST | 创建 |

### 修改接口
[变更内容]

## 错误处理

### 错误码
| 错误码 | 含义 | 处理方式 |
|--------|------|---------|
| E001 | 无效输入 | 返回错误信息 |

### 异常处理
[策略]

## 测试策略

### 单元测试
- 核心逻辑测试
- 边界条件测试

### 集成测试
- API 测试
- 端到端测试
```

## 检查清单

完成时检查：
- [ ] 有推荐方案及理由
- [ ] 有核心流程描述
- [ ] 有数据模型
- [ ] 有接口设计
- [ ] 有错误处理策略
- [ ] 有测试策略

## 示例

### 输入
proposal.md 说"修复新建档案后数据没清空"

### 产出
```markdown
# 修复新建档案后数据没清空 - 技术设计

## 推荐方案

### 方案选择
在 ProfileManager 中添加 resetGameEngine() 方法

### 备选方案
- 方案 A：在 PokerEngine 中添加 reset()，由调用方控制时机
- 方案 B：监听 currentProfileId 变化，自动触发重置

推荐方案 B，因为：
1. 职责清晰，ProfileManager 管理档案状态
2. 自动触发，不需要调用方记得调用
3. 符合现有模式（已有类似实现）

## 核心流程
```
用户调用 createProfile()
    ↓
ProfileManager.createProfile()
    ↓
currentProfileId setter 触发
    ↓
调用 resetGameEngine()
    ↓
PokerEngine 重置所有运行时状态
```

## 数据模型

### 新增方法
```swift
// ProfileManager
func resetGameEngine()

// PokerEngine
func resetForProfile()
```

## 接口设计
无新增接口

## 错误处理
- 不需要额外错误处理（纯内存操作）

## 测试策略

### 单元测试
- testCreateProfileResetsEngine
- testSwitchProfileResetsEngine
- testProfileDataIsolation

### 集成测试
- 创建新档案后验证状态清空
- 切换档案后验证数据隔离
```

---

## 常见问题处理

### 技术选型冲突

**问题**：团队对技术选型有分歧

**处理**：
```
推荐方案 X，原因：
1. 团队熟悉度
2. 维护成本
3. 扩展性

如果坚持方案 Y，风险是：
- 学习成本高
- 可能遇到未知问题
```

### 设计过度

**问题**：设计方案过于复杂

**处理**：
```
YAGNI（You Aren't Gonna Need It）
当前需求只需要 XXX，建议：
- 方案 A：简单实现，满足当前需求
- 方案 B：预留扩展，但增加复杂度

推荐方案 A
```

### 设计不确定

**问题**：有多个未知因素

**处理**：
```
由于 XXX 不确定，建议：
1. 先按方案 A 实现
2. 遇到不确定处，用接口隔离
3. 后续可以灵活切换实现

在 proposal 中标记为开放问题
```
